#!/usr/bin/python
def usage():
    print 'usage: cxxtags_query decl/def/ref database_dir file_name line_no column_no'
    print '     : cxxtags_query         name database_dir item_name [-f file_name] [-l line_no] [-c column_no]'
    print '     : cxxtags_query         dump database_dir table_name'

OUTPUT_DELIMITER = '|'
USE_BASE64 = 1
USE_USR2FILE_TABLE2 = False
USE_PLYVEL = False

import sys
if USE_PLYVEL:
    import plyvel
else:
    import leveldb
import cxxtags_util
import getopt
import re
import os
import time
import commands

TABLE_NAME_POS2USR_ID = "A"
TABLE_NAME_USR2GLOBAL_FILE_ID = "B"
TABLE_NAME_ID2NAME = "C"
TABLE_NAME_USR_ID2DECL = "D"
TABLE_NAME_USR2DEF = "E"
TABLE_NAME_ID2USR = "F"
TABLE_NAME_GLOBAL_FILE_ID2FILE = "G"
TABLE_NAME_CU_NAME2ID = "H"
TABLE_NAME_ID2CU = "I"
#TABLE_NAME_FID2CUID = "J"
TABLE_NAME_FILE2LOCAL_ID = "K"
TABLE_NAME_USR2REF = "L"
TABLE_NAME_USR2OVERRIDEE = "M"
TABLE_NAME_USR2OVERRIDER = "N"
TABLE_NAME_FILE_LIST = "O"
TABLE_NAME_USR2GLOBAL_FILE_ID2 = "P"
TABLE_NAME_BUILD_INFO = "Q"
TABLE_NAME_USR2ID = "R"
TABLE_NAME_CUFILES = "S"

DB_NUM = 32

gDebugMode = 0
gVerboseMode = 0
gPartialCompare = 0

SCRIPT_DIR = os.path.dirname(__file__)

ENCODING_TABLE = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H',
                  'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
                  'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
                  'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
                  'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',
                  'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
                  'w', 'x', 'y', 'z', '0', '1', '2', '3',
                  '4', '5', '6', '7', '8', '9', '+', '/']
DECODING_TABLE = {'A':0, 'B':1, 'C':2, 'D':3, 'E':4, 'F':5, 'G':6, 'H':7,
                  'I':8, 'J':9, 'K':10, 'L':11, 'M':12, 'N':13, 'O':14, 'P':15,
                  'Q':16, 'R':17, 'S':18, 'T':19, 'U':20, 'V':21, 'W':22, 'X':23,
                  'Y':24, 'Z':25, 'a':26, 'b':27, 'c':28, 'd':29, 'e':30, 'f':31,
                  'g':32, 'h':33, 'i':34, 'j':35, 'k':36, 'l':37, 'm':38, 'n':39,
                  'o':40, 'p':41, 'q':42, 'r':43, 's':44, 't':45, 'u':46, 'v':47,
                  'w':48, 'x':49, 'y':50, 'z':51, '0':52, '1':53, '2':54, '3':55,
                  '4':56, '5':57, '6':58, '7':59, '8':60, '9':61, '+':62, '/':63}

def DEBUG_PRINT(str):
    global gVerboseMode
    if gVerboseMode != 0:
        print str

class Db:
    m_instance = None
    def __init__(self, dirname):
        if USE_PLYVEL:
            self.m_instance = plyvel.DB(dirname, bloom_filter_bits=10, lru_cache_size=(128<<20))
        else:
            self.m_instance = leveldb.LevelDB(dirname, block_cache_size=(128<<20))
    def get(self, key):
        try:
            if USE_PLYVEL:
                return self.m_instance.get(key)
            else:
                return self.m_instance.Get(key)
        except KeyError as e:
            return None
    def close(self):
        if USE_PLYVEL:
            return self.m_instance.close()
        else:
            del self.m_instance

class HandlerBase:
    #
    # Base class of *Handler classes
    #

    mAllDbFileList = None
    mDbDir = ""
    mCuDbDir = ""
    #mDb = None
    mFileListDb = None
    mUsrDbName = None
    m_srcFileName = ""
    m_cuName = ""
    m_dbId = 0
    m_lineNo = 0
    m_colNo = 0
    m_fileCount = 0
    m_dbList = [None]*DB_NUM

    def __init__(self, dbDir):
        self.mUsrDbList = []
        self.mDbDir = dbDir + "/"
        self.mFileListDb = Db(dbDir + "/common")
        self.mAllDbFileList = None
        self.mCuDbDir = ""
        self.mUsrDbName = None
        self.m_srcFileName = ""
        self.m_cuName = ""
        self.m_dbId = 0
        self.m_lineNo = 0
        self.m_colNo = 0
        self.m_dbList = [None]*DB_NUM
        count = self.mFileListDb.get("file_count")
        assert count != None
        self.m_fileCount = count

    def InitDbByFilename(self, filename):
        q = TABLE_NAME_FILE_LIST + "|" + filename
        rv = self.mFileListDb.get(q)
        if rv == None:
            return None
        cuId, dbId = rv.split(",")
        self.m_dbId = dbId
        DEBUG_PRINT("InitDbByFilename: " + dbId)
        dbDirNo = self.GetDbDirNo()
        db = self.OpenDbById(dbId)
        self.m_dbList[dbDirNo] = db
        return db

    def InitUsrDb(self):
        dbList = os.listdir(self.mDbDir + "/usr_db")
        for dir in dbList:
            if re.match("^[0-9]+$", dir):
                db = Db(self.mDbDir + "/usr_db/" + dir)
                if db == None:
                    print("ERROR: db open: " + str(dir))
                    return None
                self.mUsrDbList.append(db)
        self.mUsrDbList = list(set(self.mUsrDbList))
        DEBUG_PRINT("usrDbList: " + str(self.mUsrDbList))
        return self.mUsrDbList

    def Cu2Id(self, cuName):
        return self.mFileListDb.get(TABLE_NAME_CU_NAME2ID + "|" + cuName)

    def Id2Cu(self, cuId):
        return self.mFileListDb.get(TABLE_NAME_ID2CU + "|" + cuId)

    def GetDbDirNo(self):
        return int(self.m_dbId, 16)%DB_NUM

    def GetMainDb(self):
        return self.m_dbList[int(self.m_dbId, 16)%DB_NUM]

    def OpenDbById(self, cuId):
        DEBUG_PRINT("OpenDbById: cuId: " + str(cuId))
        cmd = self.mDbDir + format(int(cuId, 16)%DB_NUM, 'x')
        DEBUG_PRINT("OpenDbById: " + cmd)
        timeS = time.time()
        db = Db(cmd)
        if db == None:
            print("ERROR:1: db_dir: "  + cuId)
            return None
        timeE = time.time()
        DEBUG_PRINT("OpenDbById: " + str((timeE-timeS)*1000.0) + " ms")
        return db

    def OpenAllDb(self):
        i = 0
        while i < DB_NUM:
            cmd = self.mDbDir + format(i, 'x')
            timeS = time.time()
            db = Db(cmd)
            if db == None:
                print("ERROR:1: db_dir: "  + i)
                return None
            timeE = time.time()
            DEBUG_PRINT("OpenAllDb: " + str((timeE-timeS)*1000.0) + " ms")
            self.m_dbList[i] = db
            i += 1
        return None

    def GetAllDbFiles(self):
        if self.mAllDbFileList == None:
            self.mAllDbFileList = cxxtags_util.get_db_file_list(self.mDbDir)
        return self.mAllDbFileList

    def EncVal(self, val):
        str = ""
        val = int(val, 16)
        str = ENCODING_TABLE[val & 0x3f]
        val >>= 6;
        while val != 0:
            str += ENCODING_TABLE[val & 0x3f]
            val >>= 6;
        return str;

    def DecVal(self, valStr):
        result = 0
        base = 1
        for c in valStr:
            val = DECODING_TABLE[c]
            result += val*base
            base <<= 6
        result = hex(result).replace("0x", "")
        return result

    #
    # get USR from location information.
    #
    def GetUsrId(self, fileName, lineNo, colNo):
        if fileName == "":
            print "ERROR: specify file name"
            sys.exit(1)
        mainDb = self.GetMainDb()
        fid = file2id(mainDb, self.m_dbId, fileName)
        DEBUG_PRINT("fid: " + str(fid) + "," + fileName)
        q = self.m_dbId + TABLE_NAME_POS2USR_ID + "|%s|%s|%s"%(fid, lineNo, colNo)
        DEBUG_PRINT("q: " + q)
        usr = mainDb.get(q)
        DEBUG_PRINT("usrId: " + str(usr))
        if usr == None:
            DEBUG_PRINT("pos2usr failed: " + q)
            return None
        return usr

    def GetDbIdListByUsr(self, usr):
        dbIdList = []
        if USE_USR2FILE_TABLE2:
            DEBUG_PRINT("usrDbList: " + str(self.mUsrDbList))
            for db in self.mUsrDbList:
                i = 0
                while i < int(self.m_fileCount, 16) + 1:
                    q = TABLE_NAME_USR2GLOBAL_FILE_ID2 + "|" + usr + "|" + format(i, 'x')
                    res = db.get(q)
                    if res:
                        dbIdList.append(format(i, 'x'))
                    i += 1
        else:
            for db in self.mUsrDbList:
                res = db.get(TABLE_NAME_USR2GLOBAL_FILE_ID + "|" + usr)
                if res:
                    for fid in res.split(","):
                        dbIdList.append(fid)
        if dbIdList == []:
            dbIdList.append(self.m_dbId)
        return list(set(dbIdList))

    def CloseDb(self):
        if self.mFileListDb:
            self.mFileListDb.close()
            self.mFileListDb = None
        for db in self.mUsrDbList:
            db.close()
        self.mUsrDbList = []
        for db in self.m_dbList:
            if db:
                db.close()
        self.m_dbList = [None]*DB_NUM

    def PrintResult(self, name, fileName, line, col):
        if USE_BASE64 != 0:
            line = self.DecVal(line)
            col = self.DecVal(col)
        lineInt = int(line, 16)
        colInt = int(col, 16)
        print str(name) + OUTPUT_DELIMITER + str(fileName) + OUTPUT_DELIMITER + str(lineInt) + OUTPUT_DELIMITER + str(colInt) + OUTPUT_DELIMITER + str(cxxtags_util.get_line_from_file(fileName, lineInt))

def id2usr(db, dbId, id):
    result = db.get(dbId + TABLE_NAME_ID2USR + "|%s"%(str(id)))
    return result
def usr2id(db, dbId, usr):
    result = db.get(dbId + TABLE_NAME_USR2ID + "|%s"%(str(usr)))
    return result
def id2name(db, dbId, id):
    result = db.get(dbId + TABLE_NAME_ID2NAME + "|%s"%(str(id)))
    return result
def id2file(db, dbId, id):
    result = db.get(dbId + TABLE_NAME_GLOBAL_FILE_ID2FILE + "|%s"%(str(id)))
    return result
def file2id(db, dbId, filename):
    result = db.get(dbId + TABLE_NAME_FILE2LOCAL_ID + "|%s"%(filename))
    return result
def GetResultString(db, dbId, nameId, fileId):
    name = id2name(db, dbId, nameId)
    if name == None:
        print("ERRRO: name lookup failed: " + str(nameId) + ": " + dbId)
        return None
    DEBUG_PRINT("name: " + str(nameId) + "," + str(name))
    fn = id2file(db, dbId, fileId)
    if fn == None:
        print("ERRRO: file name lookup failed: " + str(fileId) + ": " + dbId)
        return None
    DEBUG_PRINT("filename: " + str(fileId) + "," + str(fn))
    return name, fn

class QueryHandlerDecl(HandlerBase):
    #
    # Handle Rquest for infomation about declarations
    #
    def DoQuery(self):
        self.InitUsrDb()
        if self.InitDbByFilename(self.m_srcFileName) == None:
            print "ERROR: cannot open database of '%s'"%(self.m_srcFileName)
            sys.exit(1)
        usrId = self.GetUsrId(self.m_srcFileName, self.m_lineNo, self.m_colNo)
        DEBUG_PRINT("usrId: " + str(usrId))
        if usrId:
            result = self.QueryDeclInfo(usrId)
            if result:
                name, fileName, line, col = result
                self.PrintResult(name, fileName, line, col)
                return True
        # search def table in this compile unit
        return False

    def QueryDeclInfo(self, usrId):
        mainDb = self.GetMainDb()
        usr = id2usr(mainDb, self.m_dbId, usrId)
        rv = mainDb.get(self.m_dbId + TABLE_NAME_CUFILES)
        assert rv != None
        dbIdList = rv.split(",")[1:]
        DEBUG_PRINT("dbIdList: " + str(dbIdList))
        result = []
        DEBUG_PRINT("usr: " + usr)
        for dbId in dbIdList:
            idx = int(dbId, 16)%DB_NUM
            db = self.m_dbList[idx]
            if db == None:
                db = self.OpenDbById(dbId)
                self.m_dbList[idx] = db
            usrId = usr2id(db, dbId, usr)
            if usrId == None:
                continue
            DEBUG_PRINT("usrId: " + usrId)
            q = dbId + TABLE_NAME_USR_ID2DECL + "|%s"%(usrId)
            DEBUG_PRINT("q: " + q)
            decl = db.get(q)
            DEBUG_PRINT("decl: " + str(decl))
            if decl:
                nameId, fileId, line, col = decl.split("|")
                name, fileName = GetResultString(db, dbId, nameId, fileId)
                if fileName != None and name != None:
                    return name, fileName, line, col
        return None


    def parseArg(self, argv):
        if len(argv) != 3:
            usage()
            sys.exit(1)
        self.m_srcFileName, self.m_lineNo, self.m_colNo = argv
        self.m_lineNo = format(int(self.m_lineNo), 'x')
        self.m_colNo = format(int(self.m_colNo), 'x')
        if USE_BASE64 != 0:
            self.m_lineNo = self.EncVal(self.m_lineNo)
            self.m_colNo = self.EncVal(self.m_colNo)
        self.m_srcFileName = os.path.abspath(self.m_srcFileName)
        DEBUG_PRINT("src: " + self.m_srcFileName)

class QueryHandlerDef(HandlerBase):
    #
    # Handle Rquest for infomation about definition
    #
    m_isOnlyMainCompileUnit = False
    m_mainDb = None
    def DoQuery(self, isOnlyMainCompileUnit):
        self.m_isOnlyMainCompileUnit = isOnlyMainCompileUnit
        self.InitUsrDb()
        if self.InitDbByFilename(self.m_srcFileName) == None:
            print "ERROR: cannot open database of '%s'"%(self.m_srcFileName)
            sys.exit(1)
        usrId = self.GetUsrId(self.m_srcFileName, self.m_lineNo, self.m_colNo)
        usr = id2usr(self.GetMainDb(), self.m_dbId, usrId)
        DEBUG_PRINT("usr: " + str(usr))
        if usr:
            result = self.GetDef(usr)
            for r in result:
                name, fileName, line, col = r
                self.PrintResult(name, fileName, line, col)

    def GetDef(self, usr):
        dbIdList = []
        if self.m_isOnlyMainCompileUnit == False:
            dbIdList = self.GetDbIdListByUsr(usr)
        else:
            rv = self.GetMainDb().get(self.m_dbId + TABLE_NAME_CUFILES)
            assert rv != None
            dbIdList = rv.split(",")[1:]
        DEBUG_PRINT("dbIdList: " + str(dbIdList))
        DEBUG_PRINT("m_dbList: " + str(self.m_dbList))
        result = []
        for dbId in dbIdList:
            idx = int(dbId, 16)%DB_NUM
            db = self.m_dbList[idx]
            if db == None:
                db = self.OpenDbById(dbId)
                self.m_dbList[idx] = db
            #q = self.m_dbId + TABLE_NAME_USR2DEF + "|%s"%(usr)
            q = dbId + TABLE_NAME_USR2DEF + "|%s"%(usr)
            DEBUG_PRINT("q: " + q)
            resDef = db.get(q)
            DEBUG_PRINT("def: " + str(resDef))
            if resDef:
                defList = resDef.split("|")
                nameId, fileId, line, col = tuple(defList)
                name, fileName = GetResultString(db, dbId, nameId, fileId)
                if fileName != None and name != None:
                    result.append((name, fileName, line, col))
        return result

    def parseArg(self, argv):
        if len(argv) != 3:
            usage()
            sys.exit(1)
        self.m_srcFileName, self.m_lineNo, self.m_colNo = argv
        self.m_lineNo = format(int(self.m_lineNo), 'x')
        self.m_colNo = format(int(self.m_colNo), 'x')
        if USE_BASE64 != 0:
            self.m_lineNo = self.EncVal(self.m_lineNo)
            self.m_colNo = self.EncVal(self.m_colNo)
        self.m_srcFileName = os.path.abspath(self.m_srcFileName)

class QueryHandlerRef(HandlerBase):
    #
    # Handle Rquest for infomation about reference
    #
    def DoQuery(self):
        startTime = time.time()
        self.InitUsrDb()
        if self.InitDbByFilename(self.m_srcFileName) == None:
            print "ERROR: cannot open database of '%s'"%(self.m_srcFileName)
            sys.exit(1)
        usrId = self.GetUsrId(self.m_srcFileName, self.m_lineNo, self.m_colNo)
        mainDb = self.GetMainDb()
        usr = id2usr(mainDb, self.m_dbId, usrId)
        endTime = time.time()
        DEBUG_PRINT("usr: " + str(usr) + ": " + str((endTime-startTime)*1000) + " ms")
        if usr:
            self.GetAllRefs(usr)

    def GetAllRefs(self, usr):
        startTime = time.time()
        dbIdList = self.GetDbIdListByUsr(usr)
        endTime = time.time()
        DEBUG_PRINT("get all CUs: TIME: %s ms"%(str((endTime-startTime)*1000.0)))
        prevTime = 0
        DEBUG_PRINT("cu list: " + str(dbIdList))
        for dbId in dbIdList:
            DEBUG_PRINT("ref interval: " + str((time.time()-prevTime)*1000))
            prevTime = time.time()
            resultList = []
            idx = int(dbId, 16)%DB_NUM
            db = self.m_dbList[idx]
            if db == None:
                db = self.OpenDbById(dbId)
                self.m_dbList[idx] = db
            count = 0
            DEBUG_PRINT("time: open: " + dbId + ": " + str((time.time()-prevTime)*1000) + " ms")
            timeDb0 = time.time()
            #q = TABLE_NAME_USR2REF + "|" + str(usr) + "|" + str(dbId)
            q = dbId + TABLE_NAME_USR2REF + "|" + str(usr)
            rv = db.get(q)
            timeDb1 = time.time()
            DEBUG_PRINT("usr2ref: " + str(rv) + ": " + str(timeDb1-timeDb0) + " sec")
            if rv:
                rvList = rv.split(",")
                for rv in rvList:
                    nameId, fileId, line, col = rv.split("|")
                    name, fn = GetResultString(db, dbId, nameId, fileId)
                    if fn != None and name != None:
                        resultList.append((name, fn, line, col))
            for i in set(resultList):
                resultName, resultFileName, resultLine, resultCol = i
                self.PrintResult(resultName, resultFileName, resultLine, resultCol)

    def parseArg(self, argv):
        if len(argv) != 3:
            usage()
            sys.exit(1)
        self.m_srcFileName, self.m_lineNo, self.m_colNo = argv
        self.m_lineNo = format(int(self.m_lineNo), 'x')
        self.m_colNo = format(int(self.m_colNo), 'x')
        if USE_BASE64 != 0:
            self.m_lineNo = self.EncVal(self.m_lineNo)
            self.m_colNo = self.EncVal(self.m_colNo)

class QueryHandlerOverride(HandlerBase):
    #
    # Handle Rquest for infomation about reference
    #
    def DoQuery(self):
        startTime = time.time()
        self.InitUsrDb()
        if self.InitDbByFilename(self.m_srcFileName) == None:
            print "ERROR: cannot open database of '%s'"%(self.m_srcFileName)
            sys.exit(1)
        usrId = self.GetUsrId(self.m_srcFileName, self.m_lineNo, self.m_colNo)
        usr = id2usr(self.GetMainDb(), self.m_dbId, usrId)
        DEBUG_PRINT("usr: " + str(usr))
        if usr:
            self.GetAllOverrides(usr)

    def GetAllOverrides(self, usr):
        resultList = []
        mainDb = self.GetMainDb()
        q = self.m_dbId + TABLE_NAME_USR2OVERRIDER + "|" + str(usr)
        rv = mainDb.get(q)
        DEBUG_PRINT("q: " + str(q))
        DEBUG_PRINT("usr2overrirder: " + str(rv))
        if rv:
            rvList = rv.split(",")
            for rv in rvList:
                usrId = rv
                decl = mainDb.get(self.m_dbId + TABLE_NAME_USR_ID2DECL + "|%s"%(usrId))
                nameId, fileId, line, col = decl.split("|")
                name, fn = GetResultString(mainDb, self.m_dbId, nameId, fileId)
                if fn != None and name != None:
                    resultList.append((name, fn, line, col))
        for i in resultList:
            resultName, resultFileName, resultLine, resultCol = i
            self.PrintResult(resultName, resultFileName, resultLine, resultCol)

    def parseArg(self, argv):
        if len(argv) != 3:
            usage()
            sys.exit(1)
        self.m_srcFileName, self.m_lineNo, self.m_colNo = argv
        self.m_lineNo = format(int(self.m_lineNo), 'x')
        self.m_colNo = format(int(self.m_colNo), 'x')
        if USE_BASE64 != 0:
            self.m_lineNo = self.EncVal(self.m_lineNo)
            self.m_colNo = self.EncVal(self.m_colNo)

class QueryHandlerOverrideN(HandlerBase):
    #
    # Handle Rquest for infomation about reference
    #
    def DoQuery(self):
        startTime = time.time()
        self.InitUsrDb()
        if self.InitDbByFilename(self.m_srcFileName) == None:
            print "ERROR: cannot open database of '%s'"%(self.m_srcFileName)
            sys.exit(1)
        usrId = self.GetUsrId(self.m_srcFileName, self.m_lineNo, self.m_colNo)
        usr = id2usr(self.GetMainDb(), self.m_dbId, usrId)
        DEBUG_PRINT("usr: " + str(usr))
        if usr:
            self.GetAllOverriders(usr)

    def GetAllOverriders(self, usr):
        dbIdList = self.GetDbIdListByUsr(usr)
        DEBUG_PRINT("dbIdList: " + str(dbIdList))
        resultList = []
        for dbId in dbIdList:
            idx = int(dbId, 16)%DB_NUM
            db = self.m_dbList[idx]
            if db == None:
                db = self.OpenDbById(dbId)
                self.m_dbList[idx] = db
            count = 0
            q = dbId + TABLE_NAME_USR2OVERRIDEE + "|" + str(usr)
            DEBUG_PRINT("q: " + q)
            rv = db.get(q)
            DEBUG_PRINT("usr2overrirden: " + str(rv))
            if rv:
                rvList = rv.split(",")
                for rv in rvList:
                    nameId, fileId, line, col = rv.split("|")
                    name, fn = GetResultString(db, dbId, nameId, fileId)
                    if name != None and fn != None:
                        resultList.append((name, fn, line, col))
        for i in set(resultList):
            name, fn, line, col = i
            self.PrintResult(name, fn, line, col)

    def parseArg(self, argv):
        if len(argv) != 3:
            usage()
            sys.exit(1)
        self.m_srcFileName, self.m_lineNo, self.m_colNo = argv
        self.m_lineNo = format(int(self.m_lineNo), 'x')
        self.m_colNo = format(int(self.m_colNo), 'x')
        if USE_BASE64 != 0:
            self.m_lineNo = self.EncVal(self.m_lineNo)
            self.m_colNo = self.EncVal(self.m_colNo)

class QueryHandlerName(HandlerBase):
    #
    # Handle Rquest for infomation about name
    #
    mName = 0
    def DoQuery(self):
        resultList = []
        # get compileunit
        if None == self.InitUsrDb():
            print "ERROR: DB oopen"
            return None
        for usrDb in self.mUsrDbList:
            for l in usrDb:
                cre = re.compile(TABLE_NAME_USR2GLOBAL_FILE_ID + r'\\|.*' + self.mName)
                if cre.search(l[0]):
                    (tbl, usr) = l[0].split("|")
                    dbIdList = self.GetDbIdListByUsr(usr)
                    for dbId in dbIdList:
                        db = self.OpenDbById(dbId)
                        q = TABLE_NAME_USR2DEF + "|" + usr
                        val = db.get(q)
                        if val != None:
                            nameId, fileId, line, col = val.split("|")
                            name, fn = GetResultString(db, nameId, fileId)
                            if name != None and fn != None:
                                resultList.append((name, fn, line, col))
                        q = TABLE_NAME_USR2REF + "|" + usr
                        val = db.get(q)
                        if val != None:
                            nameId, fileId, line, col = val.split("|")
                            name, fn = GetResultString(db, nameId, fileId)
                            if name != None and fn != None:
                                resultList.append((name, fn, line, col))
                        db.close()
        resultList = list(set(resultList))
        for i in set(resultList):
            name, fn, line, col = i
            self.PrintResult(name, fn, line, col)

    def parseArg(self, argv):
        global gPartialCompare
        try:
            optlist, args = getopt.gnu_getopt(argv, 'f:dp', ['debug', 'partial'])
        except getopt.GetoptError, e:
            print "ERROR: getopt: ", e.args[0]
            sys.exit(1)
        if len(args) != 1:
            usage()
            sys.exit(1)
        name = args[0]
        fileName = ""
        lineNo = -1
        colNo = -1
        for opt, val in optlist:
            if opt == "-f":
                fileName = val
            elif opt in ("-p", "--partial"):
                gPartialCompare = 1
        self.mName = name
        self.m_srcFileName = fileName
        self.m_lineNo = lineNo
        self.m_colNo = colNo
        if USE_BASE64 != 0:
            self.m_lineNo = self.EncVal(self.m_lineNo)
            self.m_colNo = self.EncVal(self.m_colNo)

class QueryHandlerTable(HandlerBase):
    #
    # Handle Rquest for dumping the contents of a table
    #

    mTableName = ""
    def DoQuery(self):
        dbList = self.GetAllDbFiles()
        tableQueryStr = ""
        tableQueryCondStr = ""
        if self.mTableName == "decl":
            tableQueryStr = cxxtags_util.QUERY_JOINED_TABLE_DECL
        elif self.mTableName == "def":
            tableQueryStr = cxxtags_util.QUERY_JOINED_TABLE_DECL
            tableQueryCondStr = "WHERE decl.is_def=1"
        elif self.mTableName == "ref":
            tableQueryStr = cxxtags_util.QUERY_JOINED_TABLE_REF
        elif self.mTableName == "base_class":
            tableQueryStr = cxxtags_util.QUERY_JOINED_TABLE_BASE_CLASS
        else:
            print "ERROR: not such table: " + self.mTableName
            return
        for fn in dbList:
            db = cxxtags_util.db_connect(fn)
            cur = db.cursor()
            cur.execute('SELECT * FROM ' + tableQueryStr + ' ' + tableQueryCondStr)
            result = cur.fetchall()
            for i in result:
                print i
            db.close()

    def parseArg(self, argv):
        if len(argv) != 1:
            usage()
            sys.exit(1)
        self.mTableName = argv[0]

class QueryHandlerRebuild(HandlerBase):
    def DoQuery(self):
        if self.InitDbByFilename(self.m_srcFileName) == None:
            print "ERROR: cannot open database of '%s'"%(self.m_srcFileName)
            sys.exit(1)
        rv = self.GetMainDb().get(self.m_dbId + TABLE_NAME_BUILD_INFO)
        assert rv != None
        workDir, excludes, opt = rv.split("|")
        if excludes != "":
            excludes = " -e " + excludes
        cmd = "cxxtags -f " + excludes + " " + self.mDbDir + " " + self.m_srcFileName + " " + opt
        self.CloseDb()
        (rv, out) = commands.getstatusoutput(cmd)
        print out
        return 

    def parseArg(self, argv):
        print argv
        if len(argv) != 1:
            usage()
            sys.exit(1)
        self.m_srcFileName = os.path.abspath(argv[0])

class QueryHandlerType(HandlerBase):
    #
    # Handle Rquest for infomation about type
    #
    def DoQuery(self):
        usr = self.GetUsrId(self.m_srcFileName, self.m_lineNo, self.m_colNo)
        DEBUG_PRINT("usr: " + str(usr))
        if usr:
            typeUsr = self.GetTypeUsr(usr, self.m_srcFileName, self.m_lineNo, self.m_colNo)
            usrList = self.GetBaseClassInfo(typeUsr)
            if usrList:
                for i in usrList:
                    baseUsr, accessibility = i
                    self.GetTypeInfo(baseUsr, self.m_srcFileName, self.m_lineNo, self.m_colNo)
            self.GetTypeInfo(typeUsr, self.m_srcFileName, self.m_lineNo, self.m_colNo)

    def GetTypeInfo(self, typeUsr, fileName, lineNo, colNo):
        done_dict = {}
        if typeUsr != "":
            try:
                db = cxxtags_util.db_connect(self.mUsrDbName)
                cur = db.cursor()
                # get type name
                q = 'SELECT name_list.name FROM '+ cxxtags_util.QUERY_JOINED_TABLE_DECL + ' WHERE usr_list.name=?'
                cur.execute(q, (typeUsr,))
                result = cur.fetchone()
                typeName = ""
                if result:
                    typeName, = result
                q = 'SELECT usr_list.name, name_list.name, file_list.name, decl.line, decl.col FROM '+ cxxtags_util.QUERY_JOINED_TABLE_DECL + ' WHERE usr_list.name LIKE ? ORDER BY decl.is_def'
                cur.execute(q, (typeUsr+'%',))
                result = cur.fetchall()
            except sqlite3.Error, e:
                print "ERROR: type info: ", e.args[0]
                sys.exit(1)
            finally:
                db.close()
            typeUsrPrint = typeUsr.replace("c:", "")
            typeUsrPrint = typeUsrPrint.replace("@N@", "::")
            typeUsrPrint = typeUsrPrint.replace("@C@", "::")
            for i in result:
                resultUsr, resultName, resultFileName, resultLine, resultCol = i
                if done_dict.has_key(resultUsr):
                    continue
                done_dict[resultUsr] = 1
                if resultUsr.find(typeUsr+"@FI@") != -1: # val
                    resultUsr = resultUsr.replace(typeUsr+"@FI@", "")
                    self.PrintResult(resultName, typeName, resultFileName, resultLine, resultCol, "value")
                elif resultUsr.find(typeUsr+"@F@") != -1: # function
                    resultUsr = resultUsr.replace(typeUsr+"@F@", "")
                    resultUsr = re.sub('#.*$', "", resultUsr)
                    self.PrintResult(resultName, typeName, resultFileName, resultLine, resultCol, "function")
                elif resultUsr.find(typeUsr+"@") != -1:
                    self.PrintResult(resultUsr, typeName, resultFileName, resultLine, resultCol, "other")

    def GetTypeUsr(self, usr, fileName, lineNo, colNo):
        try:
            db = cxxtags_util.db_connect(self.mUsrDbName)
            cur = db.cursor()
            q = 'SELECT usr_list_type.name FROM '+ cxxtags_util.QUERY_JOINED_TABLE_DECL + ' WHERE usr_list.name=? LIMIT 1'
            cur.execute(q, (usr,))
            result = cur.fetchone()
        except sqlite3.Error, e:
            print "ERROR: GetTypeUsr: ", e.args[0]
            sys.exit(1)
        finally:
            db.close()
        typeUsr, = result
        return typeUsr

    def GetBaseClassInfo(self, usr):
        try:
            db = cxxtags_util.db_connect(self.mUsrDbName)
            cur = db.cursor()
            q = 'SELECT usr_list_base.name, base_class.accessibility FROM '+ cxxtags_util.QUERY_JOINED_TABLE_BASE_CLASS + ' WHERE usr_list.name=?'
            cur.execute(q, (usr,))
            result = cur.fetchall()
        except sqlite3.Error, e:
            print "ERROR: type info: ", e.args[0]
            sys.exit(1)
        finally:
            db.close()
        return result

    def parseArg(self, argv):
        if len(argv) != 3:
            usage()
            sys.exit(1)
        self.m_srcFileName, self.m_lineNo, self.m_colNo = argv
        self.m_srcFileName = os.path.abspath(self.m_srcFileName)

    def PrintResult(self, name, typeName, fileName, line, col, kind):
        print typeName + OUTPUT_DELIMITER + name + OUTPUT_DELIMITER + fileName + OUTPUT_DELIMITER + str(line) + OUTPUT_DELIMITER + str(col) + OUTPUT_DELIMITER + kind + OUTPUT_DELIMITER + cxxtags_util.get_line_from_file(fileName, line)

def main():
    global gVerboseMode
    result = []
    if len(sys.argv) <= 2:
        usage()
        sys.exit(1)

    # get global options
    gVerboseMode = 0
    try:
        optlist, argv = getopt.getopt(sys.argv[1:], 'v', [])
        for opt, val in optlist:
            if opt == "-v":
                gVerboseMode = 1
    except getopt.GetoptError, e:
        print "ERROR: getopt: ", e.args[0]
        sys.exit(1)

    queryType = argv[0]
    dbDir = argv[1]
    if queryType == 'ref': # get all references
        handler = QueryHandlerRef(dbDir)
        handler.parseArg(argv[2:])
        handler.DoQuery()
        handler.CloseDb()
    elif queryType == 'decl': # get a declaration or definition
        DEBUG_PRINT("decl start")
        handler = QueryHandlerDecl(dbDir)
        handler.parseArg(argv[2:])
        rv = handler.DoQuery()
        handler.CloseDb()
        if False == rv:
            DEBUG_PRINT("def start")
            handler = QueryHandlerDef(dbDir)
            handler.parseArg(argv[2:])
            handler.DoQuery(True)
            handler.CloseDb()
    elif queryType == 'def': # get a definition
        handler = QueryHandlerDef(dbDir)
        handler.parseArg(argv[2:])
        handler.DoQuery(False)
        handler.CloseDb()
    elif queryType == 'override': # get override information
        handler = QueryHandlerOverride(dbDir)
        handler.parseArg(argv[2:])
        handler.DoQuery()
        handler.CloseDb()
    elif queryType == 'overriden': # get overriden items
        handler = QueryHandlerOverrideN(dbDir)
        handler.parseArg(argv[2:])
        handler.DoQuery()
        handler.CloseDb()
    elif queryType == 'name': # search a name
        handler = QueryHandlerName(dbDir)
        handler.parseArg(argv[2:])
        handler.DoQuery()
        handler.CloseDb()
    elif queryType == 'dump': # dump the contents of a table
        handler = QueryHandlerTable(dbDir)
        handler.parseArg(argv[2:])
        handler.DoQuery()
        handler.CloseDb()
    elif queryType == 'rebuild': # 
        handler = QueryHandlerRebuild(dbDir)
        handler.parseArg(argv[2:])
        handler.DoQuery()
        handler.CloseDb()
        """
    elif queryType == 'type': # get type info
        handler = QueryHandlerType(dbDir)
        handler.parseArg(argv[2:])
        handler.DoQuery()
        handler.CloseDb()
        """
    else:
        print "ERROR: query type must be ref, decl, def, override, overriden, name, dump or type"
        sys.exit(1)

#######
main()
